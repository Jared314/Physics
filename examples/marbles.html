<!doctype html>
<html>
  <head>
    <title>Physics: Marble</title>
    <link rel="stylesheet" media="screen" href="../styles/style.css" />
  </head>
  <body class="marbles">
    <canvas id="splash" width="1000" height="600"></canvas>
    <script type="text/javascript" src="https://raw.github.com/mrdoob/three.js/master/build/three.min.js"></script>
    <script type="text/javascript" src="../build/physics.js"></script>
    <script type="text/javascript">

      (function() {

        // Three.js variables, i.e: Rendering variables

        var renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById('splash'),
          antialias: true
        });
        var width = renderer.domElement.width;
        var height = renderer.domElement.height;
        var center = new Physics.Vector(width / 2, height / 2);

        var scene = new THREE.Scene();
        var camera = new THREE.OrthographicCamera(0, width, 0, height, -10000);
        var light = new THREE.SpotLight(0xffffff, 10, 0, Math.PI, 10);

        light.position.set(center.x, center.y, -250);
        light.target.position.set(center.x, center.y, 0);

        var spheres = [];

        scene.add(camera);
        scene.add(light);

        // Physics related constants

        var amount = 50;
        var mass = 1, radius = 50, strength = 100000, diameter = radius * 2;

        var physics = new Physics(10);

        // Create the fixed point light / anchor that is selectable,
        // we'll call it a beacon.

        var anchor = physics.makeParticle(mass, center.x, center.y);
        anchor.makeFixed();

        var beacon = {
          color: 0xff0000,
          particle: anchor
        };
        beacon.maxIntensity = 10;
        beacon.light = new THREE.PointLight(beacon.color, beacon.maxIntensity, radius * 4);
        beacon.mesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 32, 32), new THREE.MeshPhongMaterial({
          transparent: true,
          shininess: 0,
          color: beacon.color,
          shading: THREE.SmoothShading
        }));

        // Add to scene and spheres.
        scene.add(beacon.light);
        scene.add(beacon.mesh);
        spheres.push(beacon);

        // Create all other marbles.

        for (var i = 0; i < amount; i++) {
          addSphere();
        }

        // Set the size of the renderer, same as our canvas.
        renderer.setSize(width, height);

        // This is like our draw loop
        physics.onUpdate(function() {

          for (var i = 0, l = spheres.length; i < l; i++) {

            // Set the position of the mesh to the position of the particle

            var sphere = spheres[i];
            var particle = sphere.particle;
            var mesh = sphere.mesh;

            var position = mesh.position.clone(); // Store the previous position
            var theta = 360 / (Math.PI * diameter); // Convert distance to revolutions

            for (var j = i; j < l; j++) {

              if (j == i) {
                continue;
              }

              var a = particle;
              var b = spheres[j].particle;
              var d = a.distanceTo(b);

              // Collision for same mass particles
              // http://en.wikipedia.org/wiki/Elastic_collision

              if (d <= diameter) {

                var v = a.velocity.clone();
                a.velocity.copy(b.velocity).multiplyScalar(0.9);
                b.velocity.copy(v).multiplyScalar(0.9);

                if (d < diameter) {

                  // Force particles to be tangential.
                  // i.e: No sphere is ever within another sphere.

                  var makeup = (diameter - d) / 2;
                  var angle = Math.atan2(b.position.y - a.position.y, b.position.x - a.position.x);

                  b.position.x += makeup * Math.cos(angle);
                  b.position.y += makeup * Math.sin(angle);

                  angle += Math.PI;

                  a.position.x += makeup * Math.cos(angle);
                  a.position.y += makeup * Math.sin(angle);

                }

              }

            }

            // Set the new position of the marble
            mesh.position.x = particle.position.x;
            mesh.position.y = particle.position.y;

            // Calculate the "spin" of the marble
            mesh.rotation.x += theta * (particle.position.y - position.y) / 60;
            mesh.rotation.z += theta * (particle.position.x - position.x) / 60;

            if (sphere.light) {

              var normal = sphere.particle.position.distanceTo(center) / height / 2;
              sphere.light.position.set(particle.position.x, particle.position.y, 0);
              sphere.light.intensity =  Math.max((1 - normal) * sphere.maxIntensity, 0);

            }

          }

          // Render the scene and camera
          renderer.render(scene, camera);

        });

        // Let's kick off the calculations right away!
        physics.update();

        function addSphere() {

          var x = Math.random() * width * 4 - width;
          var y = Math.random() * height * 4 - height;

          // Create a Physics.Particle and Physics.Attraction to the center.
          var particle = physics.makeParticle(mass, x, y);
          var attraction = physics.makeAttraction(anchor, particle, strength, width);

          // Create a custom texture / pattern for the marble
          var texture = new THREE.Texture(getPattern());
          texture.needsUpdate = true;
          texture.anisotropy = renderer.getMaxAnisotropy();

          // Create the geometry and material for the mesh.

          var geometry = new THREE.SphereGeometry(radius, 32, 32);
          var material = new THREE.MeshPhongMaterial({
            transparent: true,
            shininess: 0,
            shading: THREE.SmoothShading,
            map: texture
          });

          // Create a mesh and add it to our scene
          var mesh = new THREE.Mesh(geometry, material);
          scene.add(mesh);

          // Expose a sphere object for accessing during render loop.
          spheres.push({
            particle: particle,
            geometry: geometry,
            material: material,
            mesh: mesh
          });

        }

        /**
         * Make various stripe patterns in canvas 2d.
         */
        function getPattern() {

          var possible = 10;

          var canvas = document.createElement('canvas');
          var ctx = canvas.getContext('2d');
          var orientation = Math.random() > 0.4 ? true: false;

          canvas.width = canvas.height = 128;

          ctx.fillStyle = 'white';
          ctx.strokeStyle = 'black';

          ctx.fillRect(0, 0, canvas.width, canvas.height);

          for (var i = 0, l = Math.round(Math.random() * possible / 2 + possible / 5); i < l; i++) {

            ctx.lineWidth = (l / possible) * canvas.height / l;

            var pct = i / l;

            var x1 = 0;
            var x2 = canvas.width;
            var y = pct * canvas.height;

            if (orientation) {

              ctx.beginPath();
              ctx.moveTo(x1, y);
              ctx.lineTo(x2, y);
              ctx.stroke();

            } else {

              ctx.beginPath();
              ctx.moveTo(y, x1);
              ctx.lineTo(y, x2);
              ctx.stroke();

            }

          }

          return canvas;

        }

      })();

    </script>
  </body>
</html>