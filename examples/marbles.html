<!doctype html>
<html>
  <head>
    <title></title>
    <link rel="stylesheet" media="screen" href="../styles/style.css" />
  </head>
  <body class="marbles">
    <canvas id="splash" width="800" height="600"></canvas>
    <script type="text/javascript" src="https://raw.github.com/mrdoob/three.js/master/build/three.min.js"></script>
    <script type="text/javascript" src="../build/physics.js"></script>
    <script type="text/javascript">

      (function() {

        // Three.js variables, i.e: Rendering variables

        var renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById('splash'),
          antialias: true
        });
        var width = renderer.domElement.width;
        var height = renderer.domElement.height;

        var scene = new THREE.Scene();
        var camera = new THREE.OrthographicCamera(0, width, 0, height, -10000);
        var light = new THREE.SpotLight(0xffffff, 3, 0, Math.PI, 10);

        light.position.set(width / 2, height / 2, -250);
        light.target.position.set(width / 2, height / 2, 0);

        var spheres = [];

        scene.add(camera);
        scene.add(light);

        // Physics related constants

        var amount = 5;
        var mass = 1, radius = 75, strength = 100000,
          restLength = radius, repulsion = 1000, threshold = 0;

        var physics = new Physics(10);
        var anchor = physics.makeParticle(mass, width / 2, height / 2);
        anchor.makeFixed();

        // Placement variables
        var columns = 5;

        for (var i = 0; i < amount; i++) {

          var pct = (i + 1) / amount;
          var offset = pct * width * columns;
          var x2 = Math.random() * width;
          var y2 = Math.random() * height;
          // var x2 = offset % width;
          // var y2 = Math.floor(offset / width) * height;

          // Create a Physics.Particle and Physics.Attraction to the center.

          var particle = physics.makeParticle(mass, x2, y2);
          var attraction = physics.makeAttraction(anchor, particle, strength, width);

          particle.attraction = attraction; // Keep track of the attraction

          // Create a custom texture / pattern for the marble

          var texture = new THREE.Texture(getPattern());
          texture.needsUpdate = true;
          texture.anistropy = 16;

          // Create the geometry and material for the mesh.

          var geometry = new THREE.SphereGeometry(radius, 32, 32);
          var material = new THREE.MeshPhongMaterial({
            transparent: true,
            shininess: 50,
            shading: THREE.SmoothShading,
            map: texture
          });

          // Create a mesh and add it to our scene
          var mesh = new THREE.Mesh(geometry, material);
          scene.add(mesh);

          // Expose a sphere object for accessing during render loop.
          spheres.push({
            particle: particle,
            geometry: geometry,
            material: material,
            mesh: mesh
          });

        }

        // Set the size of the renderer, same as our canvas.
        renderer.setSize(width, height);

        // This is like our draw loop
        physics.onUpdate(function() {

          for (var i = 0, l = spheres.length; i < l; i++) {

            // Set the position of the mesh to the position of the particle

            var sphere = spheres[i];
            var particle = sphere.particle;
            var mesh = sphere.mesh;

            var position = mesh.position.clone(); // Store the previous position
            var theta = 360 / (Math.PI * 2 * radius); // Convert distance to revolutions

            for (var j = i; j < l; j++) {

              if (j == i) {
                continue;
              }

              var a = particle;
              var b = spheres[j].particle;
              var d = a.distanceTo(b);

              // Collision for same mass particles
              // http://en.wikipedia.org/wiki/Elastic_collision

              if (d <= radius * 2) {
                var v = a.velocity.clone();
                a.velocity.copy(b.velocity);
                b.velocity.copy(v);
              }

            }

            // Set the new position of the marble
            mesh.position.x = particle.position.x;
            mesh.position.y = particle.position.y;

            // Calculate the "spin" of the marble
            mesh.rotation.x += theta * (particle.position.y - position.y) / 60;
            mesh.rotation.z += theta * (particle.position.x - position.x) / 60;

          }

          // Render the scene and camera
          renderer.render(scene, camera);

        });

        // Let's kick off the calculations right away!

        physics.update();

        /**
         * Make various stripe patterns in canvas 2d.
         */
        function getPattern() {

          var possible = 10;

          var canvas = document.createElement('canvas');
          var ctx = canvas.getContext('2d');
          var orientation = Math.random() > 0.4 ? true: false;

          canvas.width = canvas.height = 128;

          ctx.fillStyle = 'white';
          ctx.strokeStyle = 'black';

          ctx.fillRect(0, 0, canvas.width, canvas.height);

          for (var i = 0, l = Math.round(Math.random() * possible / 2 + possible / 5); i < l; i++) {

            ctx.lineWidth = (l / possible) * canvas.height / l;

            var pct = i / l;

            var x1 = 0;
            var x2 = canvas.width;
            var y = pct * canvas.height;

            if (orientation) {

              ctx.beginPath();
              ctx.moveTo(x1, y);
              ctx.lineTo(x2, y);
              ctx.stroke();

            } else {

              ctx.beginPath();
              ctx.moveTo(y, x1);
              ctx.lineTo(y, x2);
              ctx.stroke();

            }

          }

          return canvas;

        }

      })();

    </script>
  </body>
</html>