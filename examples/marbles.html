<!doctype html>
<html>
  <head>
    <title></title>
    <link rel="stylesheet" media="screen" href="../styles/style.css" />
  </head>
  <body class="marbles">
    <canvas id="splash" width="800" height="600"></canvas>
    <script type="text/javascript" src="https://raw.github.com/mrdoob/three.js/master/build/three.min.js"></script>
    <script type="text/javascript" src="../build/physics.js"></script>
    <script type="text/javascript">

      (function() {

        // Three.js variables, i.e: Rendering variables

        var renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById('splash'),
          antialias: true
        });

        var scene = new THREE.Scene();
        var camera = new THREE.OrthographicCamera(0, renderer.domElement.width, 0, renderer.domElement.height, -10000);
        var spheres = [];

        scene.add(camera);

        // Physics related constants

        var amount = 50;
        var mass = 1, radius = 50, strength = 1000000,
          restLength = radius, repulsion = 500, threshold = radius;
        var physics = new Physics(mass);

        for (var i = 0; i < amount; i++) {

          var x1 = renderer.domElement.width / 2;
          var y1 = renderer.domElement.height / 2;

          var x2 = Math.random() * renderer.domElement.width;
          var y2 = Math.random() * renderer.domElement.height;

          var anchor = physics.makeParticle(mass, x1, y1);
          var particle = physics.makeParticle(mass, x2, y2);

          anchor.makeFixed();
          var attraction = physics.makeAttraction(anchor, particle, strength, renderer.domElement.width);

        var texture = new THREE.Texture(getPattern());
        texture.needsUpdate = true;
        texture.anistropy = 16;

          var geometry = new THREE.SphereGeometry(radius, 32, 32);
          var material = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            map: texture
          });

          var mesh = new THREE.Mesh(geometry, material);
          mesh.position.z = i * 100;  // Inhabit different z-depths

          scene.add(mesh);

          spheres.push({
            particle: particle,
            anchor: anchor,
            geometry: geometry,
            material: material,
            mesh: mesh
          });

        }

        // Add repulsion between each particle and all other particles

        for (var i = 0, l = spheres.length; i < l; i++) {

          var a = spheres[i];

          for (var j = 0; j < l; j++) {

            if (j == i) {
              continue;
            }

            var b = spheres[j];

            physics.makeAttraction(a.particle, b.particle, - repulsion, threshold);

          }

        }

        renderer.setSize(renderer.domElement.width, renderer.domElement.height);

        // This is like our draw loop
        var framecount = 0;

        physics.onUpdate(function() {

          for (var i = 0, l = spheres.length; i < l; i++) {

            // Set the position of the mesh to the position of the particle

            var sphere = spheres[i];
            var particle = sphere.particle;
            var mesh = sphere.mesh;

            var position = mesh.position.clone();
            var theta = 360 / (Math.PI * 2 * radius);

            mesh.position.x = particle.position.x;
            mesh.position.y = particle.position.y;

            mesh.rotation.x += theta * (particle.position.y - position.y) / 60;
            mesh.rotation.z += theta * (particle.position.x - position.x) / 60;

          }

          framecount++;

          renderer.render(scene, camera);

        });

        // Let's kick off the calculations right away!

        physics.update();

        /**
         * Make various stripe patterns in canvas 2d.
         */
        function getPattern() {

          var possible = 10;

          var canvas = document.createElement('canvas');
          var ctx = canvas.getContext('2d');
          var orientation = Math.random() > 0.4 ? true: false;

          canvas.width = canvas.height = 128;

          ctx.fillStyle = 'white';
          ctx.strokeStyle = 'black';

          ctx.fillRect(0, 0, canvas.width, canvas.height);

          for (var i = 0, l = Math.round(Math.random() * possible / 2 + possible / 5); i < l; i++) {

            ctx.lineWidth = (l / possible) * canvas.height / l;

            var pct = i / l;

            var x1 = 0;
            var x2 = canvas.width;
            var y = pct * canvas.height;

            if (orientation) {

              ctx.beginPath();
              ctx.moveTo(x1, y);
              ctx.lineTo(x2, y);
              ctx.stroke();

            } else {

              ctx.beginPath();
              ctx.moveTo(y, x1);
              ctx.lineTo(y, x2);
              ctx.stroke();

            }

          }

          return canvas;

        }

      })();

    </script>
  </body>
</html>