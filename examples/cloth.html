<!doctype html>
<html>
  <head>
    <title>Physics: Cloth</title>
    <link rel="stylesheet" type="text/css" href="../styles/style.css" />
    <meta name="description" content="" />
  </head>
  <body>
    <canvas id="canvas-field" width="400" height="400"></canvas>
    <script type="text/javascript" src="../build/Physics.js"></script>
    <script type="text/javascript">

      var grid_size = 10;
      var last_grid = last_grid;

      var canvas = document.getElementById('canvas-field');
      var ctx = canvas.getContext('2d');
      var mouse = new Physics.Vector(null, null);

      var gravity = 0.01, drag = Physics.DEFAULT_DRAG;

      var physics = new Physics(gravity, drag);
      var corners = [];
      var current_particle;
      var particles = [];

      var gridStepX = (canvas.width / 2) / grid_size;
      var gridStepY = (canvas.height / 2) / grid_size;
      var spring = {
        strength: 0.2,
        damping: 0.1
      };

      // Make a 2D Array to hold all the particles in a grid formation.

      for (var i = 0; i < grid_size; i++) {
        particles.push([]);
      }

      // Make Particles and connecting Springs amongst columns.

      for (var i = 0; i < grid_size; i++) {
        for (var j = 0; j < grid_size; j++) {
          var mass = 0.2;
          var x = j * gridStepX + canvas.width / 4;
          var y = i * gridStepY + 20;
          particles[i][j] = physics.makeParticle(mass, x, y);
          if (j > 0) {
            var particle_a = particles[i][j - 1];
            var particle_b = particles[i][j];
            physics.makeSpring(particle_a, particle_b, spring.strength, spring.damping, gridStepX);
          }
        }
      }

      // Make springs between the rest of the particles particles amongst rows.

      for (var j = 0; j < grid_size; j++) {
        for (var i = 1; i < grid_size; i++) {
          var particle_a = particles[i - 1][j];
          var particle_b = particles[i][j];
          physics.makeSpring(particle_a, particle_b, spring.strength, spring.damping, gridStepY);
        }
      }

      last_grid = particles.length - 1;

      // Select the four corners for convenience

      corners.push(particles[0][0]);                  // North West
      corners.push(particles[0][last_grid]);          // North East
      corners.push(particles[last_grid][last_grid]);  // South East
      corners.push(particles[0][last_grid]);          // South West

      // Make the top-left and top-right particles fixed (not affected by forces).

      particles[0][0].makeFixed();
      particles[0][last_grid].makeFixed();

      // Add our draw function to Physic's loop and call an update.

      physics.onUpdate(draw).update();

      // Add mouse events.

      canvas.addEventListener('mousedown', onCanvasMouseDown, false);
      canvas.addEventListener('mousemove', onCanvasMouseMove, false);
      canvas.addEventListener('mouseup', onCanvasMouseUp, false);

      function onCanvasMouseDown(e) {

        // Get mouse position within the canvas-space.

        mouse
          .set(e.clientX, e.clientY)
          .subSelf({ x: canvas.offsetLeft, y: canvas.offsetTop });

        // Find the particle closest to the mouse position and make that
        // the particle we will drag.

        var _d;

        for (var i = 0, l = corners.length; i < l; i++) {

          var corner = corners[i];
          var d = mouse.distanceToSquared(corner.position);

          if (!_d || (_d && d < _d)) {
            current_particle = corner;
            _d = d;
          }

        }

        current_particle.makeFixed();

        onCanvasMouseMove(e);

      }

      function onCanvasMouseMove(e) {

        // Make sure we're dragging.

        if (mouse.x == null || mouse.y == null || !current_particle) {
          return;
        }

        // Get mouse position within the canvas-space.

        mouse
          .set(e.clientX, e.clientY)
          .subSelf({ x: canvas.offsetLeft, y: canvas.offsetTop });

        // Set the current particle's position to the mouse. i.e: stick it to
        // the mouse.

        current_particle.position.copy(mouse);
        current_particle.velocity.clear();

      }

      function onCanvasMouseUp(e) {

        // Reset variables

        if (current_particle !== corners[0] && current_particle !== corners[1]) {
          current_particle.fixed = false;
        }
        mouse.set(null, null);
        current_particle = undefined;

      }

      function draw() {

        // Clear the canvas.

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Fill the surface of the grid.

        ctx.fillStyle = '#f00';
        ctx.beginPath();

        // Top

        for (var i = 0; i < grid_size; i++) {

          var particle = particles[0][i];
          var position = particle.position;
          if (i === 0) {
            ctx.moveTo(position.x, position.y);
          } else {
            ctx.lineTo(position.x, position.y);
          }

        }

        // Right

        for (var i = 0; i < grid_size; i++) {

          var particle = particles[i][last_grid];
          var position = particle.position;
          ctx.lineTo(position.x, position.y);

        }

        // Bottom

        for (var i = last_grid; i >= 0; i--) {

          var particle = particles[last_grid][i];
          var position = particle.position;
          ctx.lineTo(position.x, position.y);

        }

        // Left

        for (var i = last_grid; i >= 0; i--) {

          var particle = particles[i][0];
          var position = particle.position;
          ctx.lineTo(position.x, position.y);

        }

        ctx.fill();

      }

    </script>
  </body>
</html>